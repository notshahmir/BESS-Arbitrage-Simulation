# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ia62SZ-l3i19w1zg6KNi0pLFcKuA9u-8
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Battery Energy Storage Arbitrage — 4 Sessions End-to-End (PHYSICALLY CONSISTENT)
Date window fixed: 2025-06-11 → 2025-09-08

Sessions:
A) Physics simulation (rule-based) on DA proxy
B) Perfect-foresight LP on DA proxy (cvxpy with greedy fallback)
C) DA+BM co-allocation (heuristic), with overlap ban + total power cap
D) CVaR risk optimization (Rockafellar–Uryasev) across scenarios, with overlap penalty

Outputs:
- ./reports/*.csv
- ./reports/figures/*.png
- ./reports/summary.json
"""

import os
import json
import warnings
from datetime import datetime, timedelta, date
from typing import Tuple, Dict, Optional

import numpy as np
import pandas as pd
import requests
import matplotlib.pyplot as plt

warnings.filterwarnings("ignore")


DATE_START = date(2025, 6, 11)
DATE_END   = date(2025, 9, 8)

ELEXON_BASES = [
    "https://data.elexon.co.uk/bmrs/api/v1",
    "https://bmrs.elexon.co.uk/api/v1",
]

SCENARIOS_D = 150
BETA_D = 0.95
LAMBDA_D = 0.5
OVERLAP_PENALTY_GBP_PER_MWH = 200.0

def ensure_dirs():
    os.makedirs("reports/figures", exist_ok=True)

def lineplot(idx, series_dict, title, ylabel, outfile):
    plt.figure(figsize=(12,4))
    for k,v in series_dict.items():
        plt.plot(idx, v, label=k)
    plt.title(title); plt.ylabel(ylabel); plt.xlabel("time"); plt.legend()
    plt.tight_layout(); plt.savefig(outfile, dpi=150); plt.close()


class ElexonClient:
    def __init__(self):
        self.bases = ELEXON_BASES
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'BESS-Arb/1.0'})

    def fetch_system_prices_range(self, start_date: date, end_date: date) -> pd.DataFrame:
        print(f"Attempting Elexon fetch {start_date} → {end_date}")
        records = []
        days_ok = 0
        for base in self.bases:
            cur = start_date
            while cur <= end_date:
                url = f"{base}/balancing/settlement/system-prices/{cur.isoformat()}"
                try:
                    r = self.session.get(url, timeout=20)
                    if r.status_code != 200:
                        cur += timedelta(days=1); continue
                    day = self._parse_day(r, cur)
                    if day:
                        records.extend(day); days_ok += 1
                except Exception:
                    pass
                cur += timedelta(days=1)
            if days_ok > 0:
                print(f"✓ {days_ok} days via {base}")
                break
        return pd.DataFrame(records).sort_values("datetime").reset_index(drop=True)

    def _parse_day(self, response, cur_date: date):
        try:
            data = response.json()
        except Exception:
            return []
        if isinstance(data, dict):
            data = data.get("data", data.get("results", data.get("items", [])))
        if not isinstance(data, list): return []
        out = []
        for row in data:
            if not isinstance(row, dict): continue
            sp = None
            for k in ("settlementPeriod","settlementperiod","SP","period"):
                if k in row:
                    try: sp = int(row[k]); break
                    except: pass
            if sp is None or not (1 <= sp <= 48): continue
            price = None
            for k in ("systemPrice","systemSellPrice","systemBuyPrice","price","value"):
                if k in row:
                    try: price = float(row[k]); break
                    except: pass
            if price is None: continue
            ts = pd.Timestamp(datetime.combine(cur_date, datetime.min.time()), tz="UTC") + pd.Timedelta(minutes=30*(sp-1))
            out.append({
                "datetime": ts.tz_convert(None),
                "settlement_date": cur_date.isoformat(),
                "sp": sp,
                "system_price": price
            })
        return out


def build_da_proxy_from_system_price(sp_df: pd.DataFrame) -> pd.DataFrame:
    """
    DA proxy = median(6) -> EMA(12) on System Price; clipped to DA-ish range.
    """
    if sp_df.empty:
        raise ValueError("No system price data")
    tmp = sp_df.set_index("datetime").sort_index()
    sp = tmp["system_price"].astype(float)
    med = sp.rolling(6, center=True, min_periods=1).median()
    ema = med.ewm(span=12, adjust=False).mean()
    da_proxy = ema.clip(lower=-20.0, upper=400.0)
    return pd.DataFrame({
        "datetime": da_proxy.index,
        "da_price": da_proxy.values,
        "bm_price": sp.values
    }).reset_index(drop=True)


class BatteryParams:
    def __init__(self,
                 E_max=100.0,
                 P_max=50.0,
                 eta_ch=0.95,
                 eta_dis=0.95,
                 dt=0.5,
                 c_deg=6.0,
                 soc0=50.0,
                 soc_min=5.0,
                 soc_max=95.0):
        self.E_max=E_max; self.P_max=P_max
        self.eta_ch=eta_ch; self.eta_dis=eta_dis
        self.dt=dt; self.c_deg=c_deg
        self.soc0=soc0; self.soc_min=soc_min; self.soc_max=soc_max


def session_a_physics(prices: pd.Series, params: BatteryParams) -> pd.DataFrame:
    valid = prices.dropna()
    p30 = np.nanpercentile(valid.values, 30) if len(valid)>0 else 0.0
    p70 = np.nanpercentile(valid.values, 70) if len(valid)>0 else 0.0
    soc = params.soc0
    rows=[]
    for ts, price in prices.items():
        if pd.isna(price): price = float(valid.median()) if len(valid)>0 else 50.0
        p_ch=p_dis=0.0
        if price < p30 and soc < params.soc_max:
            p_ch = min(0.8*params.P_max, (params.soc_max - soc)/params.dt)
        elif price > p70 and soc > params.soc_min:
            p_dis = min(0.8*params.P_max, (soc - params.soc_min)/params.dt)


        soc_next = soc + params.eta_ch*params.dt*p_ch - (1.0/params.eta_dis)*params.dt*p_dis
        soc_next = float(np.clip(soc_next, 0.0, params.E_max))


        revenue = price*(p_dis - p_ch)*params.dt
        deg = params.c_deg*(p_ch + p_dis)*params.dt
        pnl = revenue - deg

        rows.append({"datetime": ts, "price": price, "p_ch": p_ch, "p_dis": p_dis,
                     "soc": soc, "soc_next": soc_next, "revenue": revenue,
                     "deg_cost": deg, "pnl": pnl})
        soc = soc_next

    df = pd.DataFrame(rows).set_index("datetime")
    df["cum_pnl"] = df["pnl"].cumsum()
    return df


def pick_cvxpy_solver():
    try:
        import cvxpy as cp
    except Exception:
        return None, None
    installed = set(cp.installed_solvers())
    for s in ("ECOS","OSQP","SCS","CLARABEL"):
        if s in installed:
            return cp, s
    return cp, None


def session_b_pf_lp(da_series: pd.Series, params: BatteryParams) -> Tuple[pd.DataFrame, Dict]:
    cp, solver = pick_cvxpy_solver()
    if cp is None or solver is None:
        print("Solver not available → using greedy fallback for Session B.")
        return session_b_pf_greedy(da_series, params)

    T = len(da_series)
    price = da_series.values
    dt = params.dt

    p_ch = cp.Variable(T, nonneg=True)
    p_dis = cp.Variable(T, nonneg=True)
    soc = cp.Variable(T+1)

    constraints = [
        p_ch <= params.P_max,
        p_dis <= params.P_max,
        p_ch + p_dis <= params.P_max,
        soc[0] == params.soc0,
        soc >= params.soc_min,
        soc <= params.soc_max
    ]
    for t in range(T):
        constraints += [
            soc[t+1] == soc[t] + params.eta_ch*dt*p_ch[t] - (1.0/params.eta_dis)*dt*p_dis[t]
        ]


    constraints += [ soc[T] == params.soc0 ]

    revenue = cp.sum(cp.multiply(price, (p_dis - p_ch)*dt))
    deg = params.c_deg * cp.sum((p_ch + p_dis)*dt)
    obj = cp.Maximize(revenue - deg)

    prob = cp.Problem(obj, constraints)
    try:
        prob.solve(solver=getattr(cp, solver), verbose=False)
    except Exception as e:
        print(f"Primary solver {solver} error: {e}")
        tried = {solver}
        for alt in ("ECOS","OSQP","SCS","CLARABEL"):
            if alt in tried: continue
            if alt in cp.installed_solvers():
                try:
                    prob.solve(solver=getattr(cp, alt), verbose=False)
                    solver = alt
                    break
                except Exception:
                    tried.add(alt)
        else:
            print("All solvers failed → using greedy fallback.")
            return session_b_pf_greedy(da_series, params)

    if str(prob.status).lower().startswith("opt") is False:
        print(f"LP status={prob.status} → using greedy fallback.")
        return session_b_pf_greedy(da_series, params)

    p_ch_v = np.asarray(p_ch.value).ravel()
    p_dis_v = np.asarray(p_dis.value).ravel()
    soc_v = np.asarray(soc.value).ravel()

    rows=[]
    for (ts, pr), t in zip(da_series.items(), range(T)):
        revenue_t = pr*(p_dis_v[t]-p_ch_v[t])*dt
        deg_t = params.c_deg*(p_ch_v[t]+p_dis_v[t])*dt
        pnl_t = revenue_t - deg_t
        rows.append({
            "datetime": ts, "price": pr, "p_ch": p_ch_v[t], "p_dis": p_dis_v[t],
            "soc": soc_v[t], "revenue": revenue_t, "deg_cost": deg_t, "pnl": pnl_t
        })
    df = pd.DataFrame(rows).set_index("datetime")
    df["cum_pnl"] = df["pnl"].cumsum()
    metrics = {
        "solver_used": solver,
        "total_pnl": float(df["pnl"].sum()),
        "throughput_MWh": float(((df["p_ch"]+df["p_dis"])*dt).sum()),
        "cycles": float(((df["p_ch"]+df["p_dis"])*dt).sum()/(2*params.E_max)),
        "status": prob.status
    }
    return df, metrics

def session_b_pf_greedy(da_series: pd.Series, params: BatteryParams) -> Tuple[pd.DataFrame, Dict]:
    T = len(da_series)
    prices = da_series.values
    order = np.argsort(prices)
    low = set(order[:T//3]); high=set(order[-T//3:])

    soc = params.soc0
    rows=[]
    for idx,(ts,pr) in enumerate(da_series.items()):
        p_ch=p_dis=0.0
        if idx in low and soc < params.soc_max:
            p_ch = min(params.P_max*0.7, (params.soc_max - soc)/params.dt)
        if idx in high and soc > params.soc_min:
            p_dis = min(params.P_max*0.7, (soc - params.soc_min)/params.dt)

        if p_ch + p_dis > params.P_max:
            scale = params.P_max/(p_ch+p_dis)
            p_ch *= scale; p_dis *= scale

        soc_next = soc + params.eta_ch*params.dt*p_ch - (1.0/params.eta_dis)*params.dt*p_dis
        soc_next = float(np.clip(soc_next, 0.0, params.E_max))
        revenue = pr*(p_dis - p_ch)*params.dt
        deg = params.c_deg*(p_ch+p_dis)*params.dt
        pnl = revenue - deg
        rows.append({"datetime": ts, "price":pr, "p_ch":p_ch, "p_dis":p_dis, "soc":soc, "pnl":pnl})
        soc = soc_next


    df = pd.DataFrame(rows).set_index("datetime")
    df["cum_pnl"]=df["pnl"].cumsum()
    metrics = {
        "solver_used": "GREEDY",
        "total_pnl": float(df["pnl"].sum()),
        "throughput_MWh": float(((df["p_ch"]+df["p_dis"])*params.dt).sum()),
        "cycles": float(((df["p_ch"]+df["p_dis"])*params.dt).sum()/(2*params.E_max))
    }
    return df, metrics


def session_c_coalloc(da: pd.Series, bm: pd.Series, params: BatteryParams) -> pd.DataFrame:
    spread = (bm - da).abs()
    vol = spread.rolling(48, min_periods=1).std().fillna(spread.std())
    vol_n = (vol / (vol.quantile(0.99)+1e-6)).clip(0,1)
    spr_n = (spread / (spread.quantile(0.99)+1e-6)).clip(0,1)
    bm_attract = 0.5*(vol_n + spr_n)
    a_DA = (0.6 - 0.4*bm_attract).clip(0.2, 0.9)

    da_p25, da_p75 = np.nanpercentile(da.values, 25), np.nanpercentile(da.values, 75)
    bm_p20, bm_p80 = np.nanpercentile(bm.values, 20), np.nanpercentile(bm.values, 80)

    soc = params.soc0
    rows=[]
    for ts in da.index:
        da_cap = float(a_DA.loc[ts])*params.P_max
        bm_cap = (1.0 - float(a_DA.loc[ts]))*params.P_max

        pr_da, pr_bm = float(da.loc[ts]), float(bm.loc[ts])
        p_ch_da=p_dis_da=p_ch_bm=p_dis_bm=0.0


        if pr_da < da_p25 and soc < params.soc_max:
            p_ch_da = min(0.8*da_cap, (params.soc_max - soc)/params.dt)
        elif pr_da > da_p75 and soc > params.soc_min:
            p_dis_da = min(0.8*da_cap, (soc - params.soc_min)/params.dt)

        if pr_bm < bm_p20 and soc < params.soc_max:
            p_ch_bm = min(0.6*bm_cap, (params.soc_max - soc)/params.dt)
        elif pr_bm > bm_p80 and soc > params.soc_min:
            p_dis_bm = min(0.6*bm_cap, (soc - params.soc_min)/params.dt)


        total_ch  = p_ch_da + p_ch_bm
        total_dis = p_dis_da + p_dis_bm
        if total_ch > 0.0 and total_dis > 0.0:
            buy_val  = pr_da*p_ch_da + pr_bm*p_ch_bm
            sell_val = pr_da*p_dis_da + pr_bm*p_dis_bm
            if sell_val >= buy_val:
                p_ch_da = p_ch_bm = 0.0
            else:
                p_dis_da = p_dis_bm = 0.0
            total_ch  = p_ch_da + p_ch_bm
            total_dis = p_dis_da + p_dis_bm


        sum_power = total_ch + total_dis
        if sum_power > params.P_max + 1e-9:
            scale = params.P_max/sum_power
            p_ch_da  *= scale; p_ch_bm  *= scale
            p_dis_da *= scale; p_dis_bm *= scale
            total_ch  = p_ch_da + p_ch_bm
            total_dis = p_dis_da + p_dis_bm


        soc_next = soc + params.eta_ch*params.dt*total_ch - (1.0/params.eta_dis)*params.dt*total_dis
        soc_next = float(np.clip(soc_next, 0.0, params.E_max))


        rev_da = pr_da*(p_dis_da - p_ch_da)*params.dt
        rev_bm = pr_bm*(p_dis_bm - p_ch_bm)*params.dt
        deg = params.c_deg*(total_ch + total_dis)*params.dt
        pnl = (rev_da + rev_bm) - deg

        rows.append({
            "datetime": ts, "a_DA": float(a_DA.loc[ts]),
            "p_ch_da": p_ch_da, "p_dis_da": p_dis_da,
            "p_ch_bm": p_ch_bm, "p_dis_bm": p_dis_bm,
            "soc": soc, "pnl": pnl
        })
        soc = soc_next

    df = pd.DataFrame(rows).set_index("datetime")
    df["cum_pnl"]=df["pnl"].cumsum()
    return df

def diag_overlap_session_c(df: pd.DataFrame, params: BatteryParams):
    if df.empty: return
    ch = (df["p_ch_da"] + df["p_ch_bm"]).clip(lower=0)
    dis = (df["p_dis_da"] + df["p_dis_bm"]).clip(lower=0)
    overlap = np.minimum(ch, dis)
    print(f"Session C — periods with overlap: {(overlap > 1e-9).sum()} / {len(df)}")
    print(f"Session C — overlap energy (MWh): {(overlap*params.dt).sum():.2f}")
    print(f"Session C — max(ch+dis) vs P_max: {(ch+dis).max():.2f} vs {params.P_max:.2f}")


def generate_price_scenarios(da_base: pd.Series, bm_base: pd.Series, S: int=300, seed: int=7) -> Tuple[pd.DataFrame, pd.DataFrame]:
    rng = np.random.default_rng(seed)
    def fit_ar1(x):
        x = np.asarray(x, dtype=float)
        shift = max(1.0, 1.0 - np.min(x))
        z = np.log(np.maximum(0.1, x + shift))
        r = np.diff(z)
        if r.size < 2: return 0.0, 0.0, 0.05, shift
        phi = np.corrcoef(r[:-1], r[1:])[0,1] if r.size>1 else 0.0
        return float(np.mean(r)), float(0.0 if not np.isfinite(phi) else phi), float(np.std(r)+1e-6), shift
    def simulate_from(base: pd.Series, S:int):
        base = np.asarray(base.values, dtype=float); T = base.size
        mu, phi, sig, shift = fit_ar1(base)
        sims = np.zeros((T, S), dtype=float)
        sims[0,:] = base[0]
        for s in range(S):
            rprev=0.0; x=base[0]
            for t in range(1,T):
                eps = rng.normal(0.0, sig)
                r_t = mu + phi*rprev + eps
                x = np.exp(np.log(max(0.1, x+shift)) + r_t) - shift
                sims[t, s] = float(np.clip(x, -80.0, 800.0))
                rprev = r_t
        return sims
    da_df = pd.DataFrame(simulate_from(da_base, S), index=da_base.index, columns=[f"s{s}" for s in range(S)])
    bm_df = pd.DataFrame(simulate_from(bm_base, S), index=bm_base.index, columns=[f"s{s}" for s in range(S)])
    return da_df, bm_df

def session_d_cvar_optim(da_sims: pd.DataFrame, bm_sims: pd.DataFrame, params: BatteryParams,
                         beta: float=0.95, lam: float=0.5, gamma: float=OVERLAP_PENALTY_GBP_PER_MWH):
    cp, solver = pick_cvxpy_solver()
    if cp is None or solver is None:
        print("Solver not available → skipping CVaR optimization (Session D).")
        return None, None
    if da_sims.empty or bm_sims.empty:
        print("[WARN] No scenarios; skipping CVaR.")
        return None, None

    T = len(da_sims); S = da_sims.shape[1]; dt = params.dt

    p_ch_da = cp.Variable(T, nonneg=True)
    p_dis_da = cp.Variable(T, nonneg=True)
    p_ch_bm = cp.Variable(T, nonneg=True)
    p_dis_bm = cp.Variable(T, nonneg=True)
    a_DA = cp.Variable(T)
    soc = cp.Variable(T+1)
    o = cp.Variable(T, nonneg=True)

    cons = [
        soc[0] == params.soc0,
        soc >= params.soc_min, soc <= params.soc_max,
        a_DA >= 0.0, a_DA <= 1.0,
        p_ch_da <= a_DA*params.P_max, p_dis_da <= a_DA*params.P_max,
        p_ch_bm <= (1.0-a_DA)*params.P_max, p_dis_bm <= (1.0-a_DA)*params.P_max
    ]
    total_ch  = p_ch_da + p_ch_bm
    total_dis = p_dis_da + p_dis_bm
    cons += [ total_ch + total_dis <= params.P_max ]


    cons += [ o <= total_ch, o <= total_dis ]

    for t in range(T):
        cons += [ soc[t+1] == soc[t] + params.eta_ch*dt*total_ch[t] - (1.0/params.eta_dis)*dt*total_dis[t] ]

    profits=[]
    for s in range(S):
        pr_da = da_sims.iloc[:, s].values
        pr_bm = bm_sims.iloc[:, s].values
        rev = cp.sum(cp.multiply(pr_da, (p_dis_da - p_ch_da))*dt) + cp.sum(cp.multiply(pr_bm, (p_dis_bm - p_ch_bm))*dt)
        deg = params.c_deg * cp.sum((p_ch_da+p_dis_da+p_ch_bm+p_dis_bm)*dt)
        profits.append(rev - deg)
    profits = cp.hstack(profits)
    mean_profit = cp.sum(profits)/S
    losses = -profits

    alpha = cp.Variable()
    z = cp.Variable(S, nonneg=True)
    cons += [ z >= losses - alpha ]

    cvar = alpha + (1.0/((1.0-beta)*S))*cp.sum(z)
    overlap_penalty = gamma * cp.sum(o) * dt

    objective = cp.Minimize( (1.0 - lam)*cvar - lam*mean_profit + overlap_penalty )
    prob = cp.Problem(objective, cons)


    tried = []
    for name in (solver, "ECOS","OSQP","SCS","CLARABEL"):
        if name in tried: continue
        if name is None: continue
        try:
            prob.solve(solver=getattr(cp, name), verbose=False)
            if str(prob.status).lower().startswith("opt"):
                solver_used = name
                break
        except Exception:
            pass
        tried.append(name)
    else:
        print(f"[WARN] CVaR solve status: {prob.status}")
        return None, None

    schedule = pd.DataFrame({
        "p_ch_da": np.asarray(p_ch_da.value).ravel(),
        "p_dis_da": np.asarray(p_dis_da.value).ravel(),
        "p_ch_bm": np.asarray(p_ch_bm.value).ravel(),
        "p_dis_bm": np.asarray(p_dis_bm.value).ravel(),
        "a_DA": np.asarray(a_DA.value).ravel()
    }, index=da_sims.index)

    sol = {
        "status": prob.status,
        "solver_used": solver_used,
        "lambda": lam, "beta": beta,
        "mean_profit": float(mean_profit.value),
        "alpha_VaR_like": float(alpha.value),
        "CVaR": float(cvar.value),
        "objective": float(prob.value)
    }
    return schedule, sol


def main():
    ensure_dirs()

    print(f"Date window: {DATE_START} → {DATE_END}")
    ec = ElexonClient()
    sp = ec.fetch_system_prices_range(DATE_START, DATE_END)
    if sp.empty:
        raise RuntimeError("No System Price data fetched.")
    print(f"✓ Fetched {len(sp)} rows from Elexon.")

    prices = build_da_proxy_from_system_price(sp).set_index("datetime").sort_index()

    params = BatteryParams(
        E_max=100.0, P_max=50.0,
        eta_ch=0.95, eta_dis=0.95,
        dt=0.5, c_deg=6.0,
        soc0=50.0, soc_min=5.0, soc_max=95.0
    )


    print("Session A: physics simulation …")
    a_df = session_a_physics(prices["da_price"], params)
    a_df.to_csv("reports/session_a_physics.csv")
    lineplot(a_df.index, {"DA proxy (£/MWh)": a_df["price"]}, "DA proxy price", "£/MWh", "reports/figures/a_price.png")
    lineplot(a_df.index, {"SoC (MWh)": a_df["soc"]}, "State of Charge", "MWh", "reports/figures/a_soc.png")
    lineplot(a_df.index, {"Cum P&L (£)": a_df["cum_pnl"]}, "Cumulative P&L — Session A", "£", "reports/figures/a_pnl.png")


    print("Session B: perfect-foresight LP …")
    b_df, b_metrics = session_b_pf_lp(prices["da_price"], params)
    b_df.to_csv("reports/session_b_pf.csv")
    if b_metrics.get("solver_used") != "GREEDY":
        print(f"Session B solver: {b_metrics.get('solver_used')} (status={b_metrics.get('status')})")
    else:
        print("Session B used GREEDY fallback.")
    lineplot(b_df.index, {"SoC (MWh)": b_df["soc"]}, "SoC — Session B", "MWh", "reports/figures/b_soc.png")
    lineplot(b_df.index, {"Cum P&L (£)": b_df["cum_pnl"]}, "Cumulative P&L — Session B", "£", "reports/figures/b_pnl.png")


    print("Session C: DA + BM co-allocation …")
    c_df = session_c_coalloc(prices["da_price"], prices["bm_price"], params)
    c_df.to_csv("reports/session_c_coalloc.csv")
    diag_overlap_session_c(c_df, params)
    lineplot(c_df.index, {"a_DA": c_df["a_DA"]}, "DA Reservation a_DA", "fraction", "reports/figures/c_reservation.png")
    lineplot(c_df.index, {"Cum P&L (£)": c_df["cum_pnl"]}, "Cumulative P&L — Session C", "£", "reports/figures/c_pnl.png")


    print(f"Session D: CVaR optimization (scenarios={SCENARIOS_D}) …")
    da_sims, bm_sims = generate_price_scenarios(prices["da_price"], prices["bm_price"], S=SCENARIOS_D, seed=42)
    sched, d_sol = session_d_cvar_optim(da_sims, bm_sims, params, beta=BETA_D, lam=LAMBDA_D)
    if sched is not None:
        sched.to_csv("reports/session_d_cvar_schedule.csv", index_label="datetime")
        with open("reports/session_d_cvar_solution.json","w") as f: json.dump(d_sol, f, indent=2)
        print(f"Session D solver: {d_sol.get('solver_used')} (status={d_sol.get('status')})")
    else:
        print("CVaR skipped (no suitable solver).")


    summary = {
        "SessionA_total_pnl": float(a_df["pnl"].sum()),
        "SessionA_cycles": float(((a_df["p_ch"]+a_df["p_dis"])*params.dt).sum()/(2*params.E_max)),
        "SessionB_total_pnl": float(b_df["pnl"].sum()),
        "SessionB_cycles": float(((b_df["p_ch"]+b_df["p_dis"])*params.dt).sum()/(2*params.E_max)),
        "SessionB_solver": b_metrics.get("solver_used","NA"),
        "SessionC_total_pnl": float(c_df["pnl"].sum()),
        "SessionC_DA_share_avg": float(c_df["a_DA"].mean()) if not c_df.empty else None,
    }
    if d_sol:
        summary.update({
            "SessionD_mean_profit": d_sol["mean_profit"],
            "SessionD_alpha_VaR95_like": d_sol["alpha_VaR_like"],
            "SessionD_CVaR95": d_sol["CVaR"],
            "SessionD_lambda": d_sol["lambda"],
        })

    with open("reports/summary.json","w") as f:
        json.dump(summary, f, indent=2)

    print("\n=== SUMMARY ===")
    for k,v in summary.items():
        if isinstance(v, (float,int)):
            print(f"{k}: {v:.2f}")
        else:
            print(f"{k}: {v}")

if __name__ == "__main__":
    ensure_dirs()
    main()